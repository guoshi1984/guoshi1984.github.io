import java.util.*;
import stat.*;
class BatesProcess extends Process
{
	/* Define Bates Process(Stochastic Volatility Jump Diffusion)
	 * dS = rSdt + \sqrt{V} S dW1 
	 * + (e^J - 1) S dN - \lambda m S dt
	 * dV = \kappa(\theta - V)dt + \sigma \sqrt{V} dW2
	 * cor[dW1, dW2] = \rho dt
	 * J is Normal(\nu, \delta)
	 * */

	// constructor
	public BatesProcess(double riskFreeRate, double volatility,
				double kappa, double theta, 
				double sigma, double rho,
				double lambda, double nu, double delta) {
		this.riskFreeRate = riskFreeRate;
		this.volatility = volatility;
		this.kappa = kappa;
		this.theta = theta;
		this.sigma = sigma;
		this.rho = rho;

		this.lambda = lambda;
		this.nu = nu;
		this.delta = delta;
		this.m = Math.exp(nu + 0.5*delta*delta) - 1;
	}
	

	// override the drift
	@Override
	public double drift(double dt) {
		// drift term from geometric Brownian motion plus the drift generated by the compensated Poisson.
		return super.drift(dt) - lambda*m*dt;
	}
	

	// specify how the volatility changes
	@Override
	public void evolveVolatility(double dt, double dw1, double dw2) {
		//HestonProcess::evolveVolatility(dt, dw1, dw2);
		double nu = this.kappa*(this.theta - this.volatility*this.volatility);
		double vol2 =  this.volatility*this.volatility + nu*dt 
			+ this.sigma*this.volatility*(this.rho*dw1 
					+ Math.sqrt(1 - this.rho * this.rho)*dw2);	
		this.volatility = (vol2 > 0) ? Math.sqrt(vol2) : 0.0;
	}

	// override the jump
	public double jump(double dt, double dw) {
		int k = PoissonDistribution.generate(lambda*dt);
		return k*nu+delta*Math.sqrt(k)*dw;
	}

	private double sigma;
	private double kappa;
	private double theta;
	private double rho;

	// Number of average jumps per unit of time
	private double lambda;
	private double nu;
	private double delta;
	private double m;
}
